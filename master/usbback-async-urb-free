Subject: [PATCH 001/001] Cleanup USB requests outside of interrupt context

From: Ross Philipson <ross.philipson@gmail.com>, Tomasz Wroblewski <tomasz.wroblewski@citrix.com>

The calls to free the USB requests in interrupt context was causing an
oops in dma_free_attrs. On x84 32b it does a WARN_ON(irqs_disabled()) "for
portability". Also have to ensure the URBs do not disappear after the
completion routine runs - hold a ref count on the URBs until the final
cleanup in vusb_free_coherent.

Signed-off-by: Ross Philipson <ross.philipson@gmail.com>
----
diff --git a/drivers/usb/xen-usbback/common.h b/drivers/usb/xen-usbback/common.h
index 27977cd..76dbdb3 100644
--- a/drivers/usb/xen-usbback/common.h
+++ b/drivers/usb/xen-usbback/common.h
@@ -240,6 +240,7 @@ typedef struct {
 	int                      nr_pages;
 	int                      nr_packets;
 	struct list_head         free_list;
+	struct list_head         to_free_list;
 	struct urb               *urb;
 #ifdef USBBK_TIMEOUT
 	struct timer_list        timer;
diff --git a/drivers/usb/xen-usbback/usbback.c b/drivers/usb/xen-usbback/usbback.c
index 8e32d75..ccd3575 100644
--- a/drivers/usb/xen-usbback/usbback.c
+++ b/drivers/usb/xen-usbback/usbback.c
@@ -76,6 +76,11 @@ static pending_segment_t *pending_segments;
 static struct list_head pending_segments_free;
 static int pending_segments_free_cnt;
 
+static DEFINE_SPINLOCK(pending_to_free_lock);
+static struct list_head pending_to_free;
+static void async_free_reqs(unsigned long);
+static DECLARE_TASKLET(async_free_reqs_task, async_free_reqs, 0);
+
 static int do_usb_io_op(usbif_t *usbif);
 static void dispatch_usb_io(usbif_t *usbif,
 				 usbif_request_t *req,
@@ -274,6 +279,27 @@ static void free_req(pending_req_t *req)
 		wake_up(&pending_free_wq);
 }
 
+static void async_free_reqs(unsigned long data)
+{
+	struct list_head tmp;
+	pending_req_t *req;
+	unsigned long flags;
+
+	INIT_LIST_HEAD(&tmp);
+
+	/* copy to temp list */
+	spin_lock_irqsave(&pending_to_free_lock, flags);
+	list_splice_init(&pending_to_free, &tmp);
+	spin_unlock_irqrestore(&pending_to_free_lock, flags);
+
+	/* run actual free outside of interrupt context */
+	while (!list_empty(&tmp)) {
+		req = list_entry(tmp.next, pending_req_t, to_free_list);
+		list_del(&req->to_free_list);
+		free_req(req);
+	}
+}
+
 #ifdef INDIRECT_SEGMENTS
 static void fast_flush_area_indirect(pending_req_t *req)
 {
@@ -548,6 +574,7 @@ static void end_usb_io_op(struct urb *urb)
 	usbif_t *usbif = pending_req->usbif;
 	int status = vusb_canceling_requests(&usbif->vusb) ?
 		-ECONNRESET : urb->status;
+	unsigned long flags;
 
 	debug_print(LOG_LVL_INFO, "end id %llu len %d status %d %s\n",
 		pending_req->id, urb->actual_length, status,
@@ -575,7 +602,19 @@ static void end_usb_io_op(struct urb *urb)
 	make_response(usbif, pending_req->id, urb->actual_length,
 		urb->start_frame, get_usb_status(status));
 	usbif_put(pending_req->usbif);
-	free_req(pending_req);
+
+	/* Schedule async free as it causes an oops on 32bit kernel doing dma frees
+	 * in this completion handler with irqs disabled. There is a
+	 * WARN_ON(irqs_disabled()) in dma_free_attrs.  We have to bump the ref count
+	 * on the urb since it will be released after this completion routine returns.
+	 * See the code in hcd.c:usb_hcd_giveback_urb() that call the completion
+	 * callback.
+	 */
+	urb = usb_get_urb(urb);
+	spin_lock_irqsave(&pending_to_free_lock, flags);
+	list_add_tail(&pending_req->to_free_list, &pending_to_free);
+	spin_unlock_irqrestore(&pending_to_free_lock, flags);
+	tasklet_schedule(&async_free_reqs_task);
 }
 
 /******************************************************************************
@@ -1142,6 +1181,8 @@ static int __init usbif_init(void)
 		list_add_tail(&pending_reqs[i].free_list, &pending_free);
 	}
 
+	INIT_LIST_HEAD(&pending_to_free);
+
 	usbif_xenbus_init();
 
 	printk("USB backend driver intialized!\n");
diff --git a/drivers/usb/xen-usbback/vusb.c b/drivers/usb/xen-usbback/vusb.c
index 60b2c43..61de5a4 100644
--- a/drivers/usb/xen-usbback/vusb.c
+++ b/drivers/usb/xen-usbback/vusb.c
@@ -876,13 +876,25 @@ void vusb_free_coherent(struct vusb *vusb, struct urb *urb)
 {
 	struct usb_device *usbdev = urb->dev ? urb->dev : vusb->usbdev;
 
-	if (usbdev)
+	if (usbdev) {
+		/* This frees the dma resources for this urb */
 		usb_free_coherent(usbdev, urb->transfer_buffer_length,
 		        urb->transfer_buffer, urb->transfer_dma);
-	else
+		urb->transfer_buffer = NULL;
+
+		/* The urb had its ref count bumped before being queued for
+		 * cleanup in the bottom half async_free_reqs(). This was to
+		 * keep it alive so it can be asynchronously cleaned up.
+		 * Dropping that ref here will finally cleanup and release the
+		 * urb.
+		 */
+		usb_free_urb(urb);
+	}
+	else {
 		debug_print(LOG_LVL_ERROR, "%s: leaking buffer! no dev!",
 			__FUNCTION__);
-	urb->transfer_buffer = NULL;
+		urb->transfer_buffer = NULL;
+	}
 }
 
 void *vusb_alloc_coherent(struct vusb *vusb, size_t size, dma_addr_t *dma)
